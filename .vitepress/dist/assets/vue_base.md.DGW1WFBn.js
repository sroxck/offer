import{_ as a,c as o,a1 as t,o as r}from"./chunks/framework.C72X4JAr.js";const s=JSON.parse('{"title":"Vue 基础面试题","description":"","frontmatter":{},"headers":[],"relativePath":"vue/base.md","filePath":"vue/base.md"}'),u={name:"vue/base.md"};function l(i,e,h,d,n,c){return r(),o("div",null,e[0]||(e[0]=[t('<h1 id="vue-基础面试题" tabindex="-1">Vue 基础面试题 <a class="header-anchor" href="#vue-基础面试题" aria-label="Permalink to &quot;Vue 基础面试题&quot;">​</a></h1><h2 id="vue2-和-vue3-的区别" tabindex="-1">vue2 和 vue3 的区别 <a class="header-anchor" href="#vue2-和-vue3-的区别" aria-label="Permalink to &quot;vue2 和 vue3 的区别&quot;">​</a></h2><h2 id="谈一谈对-mvvm-的理解" tabindex="-1">谈一谈对 MVVM 的理解？ <a class="header-anchor" href="#谈一谈对-mvvm-的理解" aria-label="Permalink to &quot;谈一谈对 MVVM 的理解？&quot;">​</a></h2><h2 id="为什么-vue2-组件中的-data-是一个函数" tabindex="-1">为什么 Vue2 组件中的 data 是一个函数 <a class="header-anchor" href="#为什么-vue2-组件中的-data-是一个函数" aria-label="Permalink to &quot;为什么 Vue2 组件中的 data 是一个函数&quot;">​</a></h2><h2 id="怎么理解-vue-的单向数据流" tabindex="-1">怎么理解 Vue 的单向数据流 <a class="header-anchor" href="#怎么理解-vue-的单向数据流" aria-label="Permalink to &quot;怎么理解 Vue 的单向数据流&quot;">​</a></h2><h2 id="vue-中怎么异步加载组件" tabindex="-1">Vue 中怎么异步加载组件 <a class="header-anchor" href="#vue-中怎么异步加载组件" aria-label="Permalink to &quot;Vue 中怎么异步加载组件&quot;">​</a></h2><h2 id="v-model-双向绑定的原理是什么" tabindex="-1">v-model 双向绑定的原理是什么？ <a class="header-anchor" href="#v-model-双向绑定的原理是什么" aria-label="Permalink to &quot;v-model 双向绑定的原理是什么？&quot;">​</a></h2><h2 id="vue-组件通信方式有哪些及原理" tabindex="-1">vue 组件通信方式有哪些及原理 <a class="header-anchor" href="#vue-组件通信方式有哪些及原理" aria-label="Permalink to &quot;vue 组件通信方式有哪些及原理&quot;">​</a></h2><h2 id="vue-的生命周期有哪些及每个生命周期做了什么" tabindex="-1">vue 的生命周期有哪些及每个生命周期做了什么？ <a class="header-anchor" href="#vue-的生命周期有哪些及每个生命周期做了什么" aria-label="Permalink to &quot;vue 的生命周期有哪些及每个生命周期做了什么？&quot;">​</a></h2><h2 id="说一下-v-if-与-v-show-的区别-使用场景" tabindex="-1">说一下 v-if 与 v-show 的区别,使用场景 <a class="header-anchor" href="#说一下-v-if-与-v-show-的区别-使用场景" aria-label="Permalink to &quot;说一下 v-if 与 v-show 的区别,使用场景&quot;">​</a></h2><h2 id="vue-的路由实现-hash-路由和-history-路由实现原理说一下" tabindex="-1">Vue 的路由实现, hash 路由和 history 路由实现原理说一下 <a class="header-anchor" href="#vue-的路由实现-hash-路由和-history-路由实现原理说一下" aria-label="Permalink to &quot;Vue 的路由实现, hash 路由和 history 路由实现原理说一下&quot;">​</a></h2><h2 id="vue-中的指令是什么-常见的指令有哪些-如何自定义指令" tabindex="-1">Vue 中的指令是什么,常见的指令有哪些,如何自定义指令 <a class="header-anchor" href="#vue-中的指令是什么-常见的指令有哪些-如何自定义指令" aria-label="Permalink to &quot;Vue 中的指令是什么,常见的指令有哪些,如何自定义指令&quot;">​</a></h2><h2 id="class-与-style-如何动态绑定" tabindex="-1">Class 与 Style 如何动态绑定？ <a class="header-anchor" href="#class-与-style-如何动态绑定" aria-label="Permalink to &quot;Class 与 Style 如何动态绑定？&quot;">​</a></h2><h2 id="vue-router-怎么动态添加、删除路由" tabindex="-1">vue-router 怎么动态添加、删除路由？ <a class="header-anchor" href="#vue-router-怎么动态添加、删除路由" aria-label="Permalink to &quot;vue-router 怎么动态添加、删除路由？&quot;">​</a></h2><h2 id="虚拟-dom-的优缺点" tabindex="-1">虚拟 DOM 的优缺点？ <a class="header-anchor" href="#虚拟-dom-的优缺点" aria-label="Permalink to &quot;虚拟 DOM 的优缺点？&quot;">​</a></h2><h2 id="虚拟-dom-实现原理" tabindex="-1">虚拟 DOM 实现原理？ <a class="header-anchor" href="#虚拟-dom-实现原理" aria-label="Permalink to &quot;虚拟 DOM 实现原理？&quot;">​</a></h2><h2 id="页面刷新-vuex-数据丢失怎么处理" tabindex="-1">页面刷新 vuex 数据丢失怎么处理 <a class="header-anchor" href="#页面刷新-vuex-数据丢失怎么处理" aria-label="Permalink to &quot;页面刷新 vuex 数据丢失怎么处理&quot;">​</a></h2><h2 id="你有对-vue-项目进行哪些优化" tabindex="-1">你有对 Vue 项目进行哪些优化？ <a class="header-anchor" href="#你有对-vue-项目进行哪些优化" aria-label="Permalink to &quot;你有对 Vue 项目进行哪些优化？&quot;">​</a></h2><h2 id="说说你使用-vue-框架踩过最大的坑是什么-怎么解决的" tabindex="-1">说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？ <a class="header-anchor" href="#说说你使用-vue-框架踩过最大的坑是什么-怎么解决的" aria-label="Permalink to &quot;说说你使用 Vue 框架踩过最大的坑是什么？怎么解决的？&quot;">​</a></h2><h2 id="简述-vuex-与-pinia-如何使用-有什么区别" tabindex="-1">简述 Vuex 与 pinia,如何使用,有什么区别 <a class="header-anchor" href="#简述-vuex-与-pinia-如何使用-有什么区别" aria-label="Permalink to &quot;简述 Vuex 与 pinia,如何使用,有什么区别&quot;">​</a></h2><h2 id="直接给一个数组项赋值-vue-能检测到变化吗" tabindex="-1">直接给一个数组项赋值，Vue 能检测到变化吗 <a class="header-anchor" href="#直接给一个数组项赋值-vue-能检测到变化吗" aria-label="Permalink to &quot;直接给一个数组项赋值，Vue 能检测到变化吗&quot;">​</a></h2><h2 id="eventbus-与-mitt-区别" tabindex="-1">EventBus 与 mitt 区别？ <a class="header-anchor" href="#eventbus-与-mitt-区别" aria-label="Permalink to &quot;EventBus 与 mitt 区别？&quot;">​</a></h2><h2 id="vue3-和-vue2-响应式原理是什么-有什么区别" tabindex="-1">vue3 和 vue2 响应式原理是什么? 有什么区别 ? <a class="header-anchor" href="#vue3-和-vue2-响应式原理是什么-有什么区别" aria-label="Permalink to &quot;vue3 和 vue2 响应式原理是什么? 有什么区别 ?&quot;">​</a></h2><h2 id="vue-3-为什么使用-proxy-代替-object-defineproperty" tabindex="-1">Vue 3 为什么使用 Proxy 代替 Object.defineProperty <a class="header-anchor" href="#vue-3-为什么使用-proxy-代替-object-defineproperty" aria-label="Permalink to &quot;Vue 3 为什么使用 Proxy 代替 Object.defineProperty&quot;">​</a></h2><h2 id="vue-3-为什么推荐使用-composition-api" tabindex="-1">Vue 3 为什么推荐使用 Composition API <a class="header-anchor" href="#vue-3-为什么推荐使用-composition-api" aria-label="Permalink to &quot;Vue 3 为什么推荐使用 Composition API&quot;">​</a></h2><h2 id="vue3-和-vue2-的区别" tabindex="-1">vue3 和 vue2 的区别? <a class="header-anchor" href="#vue3-和-vue2-的区别" aria-label="Permalink to &quot;vue3 和 vue2 的区别?&quot;">​</a></h2><h2 id="v-if-与-v-for-的优先级-vue3-vue2" tabindex="-1">v-if 与 v-for 的优先级(vue3/vue2) <a class="header-anchor" href="#v-if-与-v-for-的优先级-vue3-vue2" aria-label="Permalink to &quot;v-if 与 v-for 的优先级(vue3/vue2)&quot;">​</a></h2><h2 id="怎么定义动态路由-怎么获取传过来的动态参数" tabindex="-1">怎么定义动态路由？怎么获取传过来的动态参数？ <a class="header-anchor" href="#怎么定义动态路由-怎么获取传过来的动态参数" aria-label="Permalink to &quot;怎么定义动态路由？怎么获取传过来的动态参数？&quot;">​</a></h2><h2 id="vue-中如何扩展一个组件" tabindex="-1">Vue 中如何扩展一个组件 <a class="header-anchor" href="#vue-中如何扩展一个组件" aria-label="Permalink to &quot;Vue 中如何扩展一个组件&quot;">​</a></h2><h2 id="watch-和-computed-的区别以及选择" tabindex="-1">watch 和 computed 的区别以及选择? <a class="header-anchor" href="#watch-和-computed-的区别以及选择" aria-label="Permalink to &quot;watch 和 computed 的区别以及选择?&quot;">​</a></h2><h2 id="说一下-vue-子组件和父组件创建和挂载顺序" tabindex="-1">说一下 Vue 子组件和父组件创建和挂载顺序 <a class="header-anchor" href="#说一下-vue-子组件和父组件创建和挂载顺序" aria-label="Permalink to &quot;说一下 Vue 子组件和父组件创建和挂载顺序&quot;">​</a></h2><h2 id="怎么缓存当前的组件-缓存后怎么更新" tabindex="-1">怎么缓存当前的组件？缓存后怎么更新？ <a class="header-anchor" href="#怎么缓存当前的组件-缓存后怎么更新" aria-label="Permalink to &quot;怎么缓存当前的组件？缓存后怎么更新？&quot;">​</a></h2><h2 id="说一下-vue3-中的宏有哪些" tabindex="-1">说一下 Vue3 中的宏有哪些？ <a class="header-anchor" href="#说一下-vue3-中的宏有哪些" aria-label="Permalink to &quot;说一下 Vue3 中的宏有哪些？&quot;">​</a></h2><h2 id="说一下-watch-和-watcheffect" tabindex="-1">说一下 watch 和 watchEffect? <a class="header-anchor" href="#说一下-watch-和-watcheffect" aria-label="Permalink to &quot;说一下 watch 和 watchEffect?&quot;">​</a></h2><h2 id="vue3-中-toref-和-torefs-的区别" tabindex="-1">Vue3 中 toRef 和 toRefs 的区别 <a class="header-anchor" href="#vue3-中-toref-和-torefs-的区别" aria-label="Permalink to &quot;Vue3 中 toRef 和 toRefs 的区别&quot;">​</a></h2><p><a href="https://juejin.cn/post/7352075662453702694" target="_blank" rel="noreferrer">详情</a></p><blockquote><p>vue2 与 vue3 的生命周期区别: vue3 组合式 api 增加 setup 钩子,原来 vue2 的 beforeCreate 和 created 合并为 setup ,Destroy 改为 unmount</p></blockquote><h3 id="vue2" tabindex="-1">vue2 <a class="header-anchor" href="#vue2" aria-label="Permalink to &quot;vue2&quot;">​</a></h3><p>beforeCreate</p><blockquote><p>是 new Vue()之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。</p></blockquote><p>created</p><blockquote><p>在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。</p></blockquote><p>beforeMount</p><blockquote><p>发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。</p></blockquote><p>mounted</p><blockquote><p>在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用$refs 属性对 Dom 进行操作。</p></blockquote><p>beforeUpdate</p><blockquote><p>发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。</p></blockquote><p>updated</p><blockquote><p>发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。</p></blockquote><p>beforeDestroy</p><blockquote><p>发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。</p></blockquote><p>destroyed</p><blockquote><p>发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。</p></blockquote><h3 id="vue3" tabindex="-1">vue3 <a class="header-anchor" href="#vue3" aria-label="Permalink to &quot;vue3&quot;">​</a></h3><p>setup()</p><blockquote><p>这是一个特殊的钩子，在组件实例被创建之前调用。 用于组合式 API，可以在其中定义响应式数据、方法等，返回的对象可以在模板中使用。</p></blockquote><p>beforeCreate</p><blockquote><p>在实例初始化之后，数据观测和事件配置之前被调用。</p></blockquote><p>created</p><blockquote><p>在实例创建完成后被立即调用。 此时，组件的响应式数据、计算属性、方法等已经初始化完成，但 DOM 尚未挂载。</p></blockquote><p>beforeMount</p><blockquote><p>在挂载开始之前被调用。 此时模板已经编译完成，但尚未渲染到 DOM 中。</p></blockquote><p>mounted</p><blockquote><p>挂载完成后被调用。 此时组件的 DOM 已经被渲染到页面中，可以在这个阶段进行 DOM 操作、发送网络请求等。</p></blockquote><p>beforeUpdate</p><blockquote><p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 可以在这个阶段获取更新前的状态，以便进行一些比较或处理。</p></blockquote><p>updated</p><blockquote><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。 可以在此阶段进行 DOM 操作，但要注意避免无限循环更新。</p></blockquote><p>beforeUnmount</p><blockquote><p>在卸载组件实例之前调用。 可以在这个阶段进行一些清理操作，如取消定时器、解绑事件等。</p></blockquote><p>unmounted</p><blockquote><p>卸载组件实例后调用。 此时组件的所有资源都已被释放，可以进行最后的清理工作。</p></blockquote><h3 id="选项式-api-与组合式-api-中生命周期的对应是关系是" tabindex="-1">选项式 API 与组合式 API 中生命周期的对应是关系是： <a class="header-anchor" href="#选项式-api-与组合式-api-中生命周期的对应是关系是" aria-label="Permalink to &quot;选项式 API 与组合式 API 中生命周期的对应是关系是：&quot;">​</a></h3><ul><li><p>beforeCreate 、created 对应 setup 函数</p></li><li><p>beforeMount 、mounted 对应 onBeforeMount() 和 onMounted()</p></li><li><p>beforeUpdate 、updated 对应 onBeforeUpdate() 和 onUpdated()</p></li><li><p>beforeUnmount、unmounted 对应 onBeforeUnmount() 和 onUnmounted()</p></li><li><p>errorCaptured 对应 onErrorCaptured()</p></li><li><p>renderTracked 、renderTriggered 对应 onRenderTracked() 和 onRenderTriggered()</p></li><li><p>activated、deactivated 对应 onActivated() 和 onDeactivated()</p></li><li><p>serverPrefetch 对应 onServerPrefetch()</p></li></ul><blockquote><p>其中 onRenderTracked() 和 onRenderTriggered() 是 Vue3 新增的用于调试的生命周期钩子。</p></blockquote>',76)]))}const b=a(u,[["render",l]]);export{s as __pageData,b as default};
