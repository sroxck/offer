# JS 基础面试题

::: tip

基础是一定要掌握的,哪怕不面试,也需要掌握并牢记

- 变量和数据类型: 掌握常见的数据类型（包括数字、字符串、布尔值、对象、数组等）及其使用方法。
- 运算符和表达式: 掌握运算符及其优先级，常见运算符的使用方法。
- 函数: 掌握作用域和闭包等基本概念
- 异步编程: 掌握 JavaScript 中的异步编程机制和常见的异步编程方法，如回调函数、Promise、async/await 等。
- 正则表达式: 掌握正则表达式的基本语法和用法，能够使用正则表达式进行字符串的匹配和替换操作。
- 错误处理和调试: 掌握 JavaScript 中的错误类型和异常处理机制,掌握常用的调试工具和技巧。
- ES6+ 新特性: 掌握 ES6+ 中新增的语法和特性，如箭头函数、模板字符串、解构赋值、let/const、class、模块化等，能够灵活运用这些特性提高编程效率和代码质量。

:::

## JavaScript 有哪些数据类型，它们的区别？

## 数据类型检测的方式有哪些

## 判断数组的方式有哪些

## null 和 undefined 区别

## intanceof 操作符的实现原理及实现

## let、const、var 的区别

1. 块级作用域： 块作用域由 { }包括，let 和 const 具有块级作用域，var 不存在块级作用域。块级作用域解决了 ES5 中的两个问题：
   > 内层变量可能覆盖外层变量
   > 用来计数的循环变量泄露为全局变量
2. 变量提升： var 存在变量提升，let 和 const 不存在变量提升，即在变量只能在声明之后使用，否在会报错。
3. 给全局添加属性： 浏览器的全局对象是 window，Node 的全局对象是 global。var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会。
4. 重复声明： var 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const 和 let 不允许重复声明变量。
5. 暂时性死区： 在使用 let、const 命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用 var 声明的变量不存在暂时性死区。
6. 初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。
7. 指针指向： let 和 const 都是 ES6 新增的用于创建变量的语法。 let 创建的变量是可以更改指针指向（可以重新赋值）。但 const 声明的变量是不允许改变指针的指向。

| 区别               | var | let | const |
| ------------------ | --- | --- | ----- |
| 是否有块级作用域   | ×   | ✔️  | ✔️    |
| 是否存在变量提升   | ✔️  | ×   | ×     |
| 是否添加全局属性   | ✔️  | ×   | ×     |
| 能否重复声明变量   | ✔️  | ×   | ×     |
| 是否存在暂时性死区 | ✔️  | ×   | ×     |
| 是否必须设置初始值 | ✔️  | ×   | ✔️    |
| 能否改变指针指向   | ✔️  | ✔️  | ×     |

## const 对象的属性可以修改吗

const 保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。
但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const 只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。

## 箭头函数与普通函数的区别

### 箭头函数比普通函数更加简洁

- 如果没有参数，就直接写一个空括号即可
- 如果只有一个参数，可以省去参数的括号
- 如果有多个参数，用逗号分割
- 如果函数体的返回值只有一句，可以省略大括号
- 如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个 void 关键字。最常见的就是调用一个函数：

```js
let fn = () => void doesNotReturn();
```

### 箭头函数没有自己的 this

箭头函数不会创建自己的 this， 所以它没有自己的 this，它只会在自己作用域的上一层继承 this。所以箭头函数中 this 的指向在它在定义时已经确定了，之后不会改变。

### 箭头函数继承来的 this 指向永远不会改变

```js
var id = "GLOBAL";
var obj = {
  id: "OBJ",
  a: function () {
    console.log(this.id);
  },
  b: () => {
    console.log(this.id);
  },
};
obj.a(); // 'OBJ'
obj.b(); // 'GLOBAL'
new obj.a(); // undefined
new obj.b(); // Uncaught TypeError: obj.b is not a constructor
```

对象 obj 的方法 b 是使用箭头函数定义的，这个函数中的 this 就永远指向它定义时所处的全局执行环境中的 this，即便这个函数是作为对象 obj 的方法调用，this 依旧指向 Window 对象。需要注意，定义对象的大括号{}是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。

### call()、apply()、bind()等方法不能改变箭头函数中 this 的指向

```js
var id = "Global";
let fun1 = () => {
  console.log(this.id);
};
fun1(); // 'Global'
fun1.call({ id: "Obj" }); // 'Global'
fun1.apply({ id: "Obj" }); // 'Global'
fun1.bind({ id: "Obj" })(); // 'Global'
```

### 箭头函数不能作为构造函数使用

构造函数在 new 的步骤在上面已经说过了，实际上第二步就是将函数中的 this 指向该对象。 但是由于箭头函数时没有自己的 this 的，且 this 指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。

### 箭头函数没有自己的 arguments

箭头函数没有自己的 arguments 对象。在箭头函数中访问 arguments 实际上获得的是它外层函数的 arguments 值。

### 箭头函数没有 prototype

### 箭头函数不能用作 Generator 函数，不能使用 yeild 关键字

## 箭头函数的 this 指向哪⾥？

箭头函数不同于传统 JavaScript 中的函数，箭头函数并没有属于⾃⼰的 this，它所谓的 this 是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的 this，所以是不会被 new 调⽤的，这个所谓的 this 也不会被改变。

## 什么是 js 的闭包？有什么作用？

> 老生长谈的问题,现在有可能都不会被问了,这个太经典了
> 闭包（Closure）指的是函数和其词法环境的组合，即在函数内部定义的函数可以访问外部函数的变量和参数，即使这些变量和参数在外部函数执行完毕后也不会被销毁。由于闭包可以访问外部函数的变量和参数，因此可以使用闭包在外部函数执行完毕后，继续访问和操作外部函数的变量和参数，从而实现一些高级的编程技巧，如柯里化、函数式编程、事件监听等。

闭包的核心是函数和词法环境的组合，词法环境是指函数执行时内部变量和参数的存储空间，它包含了函数内部定义的所有变量和参数，以及它所处的外部环境中的变量和参数。当一个函数被定义时，它会创建一个新的词法环境，并将其保存在函数内部。当函数被调用时，它会使用自己内部的词法环境来访问变量和参数。

闭包的作用是可以用来创建独立的、私有的变量或方法，这些变量和方法只能在闭包内部访问，外部无法访问。由于闭包可以访问外层函数的变量和参数，因此可以使用闭包在外部函数执行完毕后，继续访问和操作外部函数的变量和参数，从而实现一些高级的编程技巧，如柯里化、函数式编程、事件监听等。

需要注意的是，闭包可能会导致内存泄漏问题，因为闭包会维持外部变量和参数的引用，如果这些变量和参数占用的内存较大，且不及时释放，可能会导致内存泄漏。因此在使用闭包时需要谨慎，及时释放不再需要的变量和参数的引用。

## JS 数组的常用的方法有哪些？

> 根据数组的特点来总结，例如：增删改查、排序、转换、迭代。 这样我们才可以保证我们可以完全的给面试官总结清楚。

```js
// 增：
push() unshift() splice() concat()
// 删：
pop() shift() splice() slice('不改变原数组')
// 改：
splice()
// 查：
indexOf() includes() find()
// 排序:
sort()  reverse()
// 迭代:
forEach() map() filter() some() every()

```

## 双等和三等的区别

对于 == ，如果双方的类型不一样的话，就会进行类型转换 再进行比较。

对于 === 首先要求比较双方类型相同, 再比较值是否相同。

## 说说函数的防抖和节流

1. 函数的防抖和节流都是用来优化体验，减少相同函数没有必要的调用

2. 防抖是在规定时间内，没有再次触发，则执行函数 节流是在规定时间内，不管函数触发多少次，只执行一次

### 使用场景

#### **防抖**

1. 比如搜索框的输入，想要在用户停止输入后再发送请求，而不是每次输入都发送请求。
2. 窗口大小变化时，只在用户停止调整窗口后执行某个操作。

#### **节流**

1. 在滚动事件中，比如监听用户的滚动位置，想要每隔一定时间处理一次，而不是每次滚动都处理。
2. 在窗口大小调整时如 resize，想要限制处理的频率，避免性能问题。

通过这两种方法，我们可以有效地提升页面性能和用户体验

## 说说 JS 数字精度丢失问题，怎么解决?

由于计算机不能存储无限长度的小数，会取其近似值。而 JS 的 Number 采取的是 IEEE754 规范的 64 位双精度浮点数 (意味着浮点数二进制 X = (-1)^s _ M _ 2^e)。

解决 Math.js bigNumber.js (x \* 10^a) / 10^a

## 说说函数式编程

函数式编程是一种编程范式，它将计算过程看作是一系列函数调用的组合。在函数式编程中，函数被视为一等公民，函数可以作为参数传递给其他函数，也可以作为返回值返回给调用者。函数式编程通常避免使用共享状态和可变数据，强调使用纯函数和不可变数据来实现程序逻辑。

在 JavaScript 中，函数式编程可以通过使用高阶函数、纯函数、柯里化、函数组合等技术实现。高阶函数是指接受一个或多个函数作为参数，并返回一个新函数的函数。纯函数是指不依赖于程序状态和副作用的函数，即对于相同的输入，总是返回相同的输出，不会修改输入参数或者对外部状态造成影响。柯里化是指将一个接收多个参数的函数转化为接收一个参数的函数序列的过程。函数组合是指将多个函数组合成一个新函数的过程。

函数式编程的优点包括代码简洁、逻辑清晰、易于测试和复用等。由于函数式编程不依赖于共享状态和可变数据，因此可以更容易地实现并行计算和分布式计算等高级计算技术。在 JavaScript 中，函数式编程也被广泛应用于 React、Redux、RxJS 等框架和库中，以实现更加可靠和高效的 Web 应用程序。
